{
  "title": "TypeScript ovunque: pattern UI più sicuri in Next.js",
  "date": "2024-01-10T00:00:00.000Z",
  "summary": "Esplorando pattern TypeScript avanzati che rendono le tue applicazioni Next.js più robuste e manutenibili.",
  "tags": [
    "TypeScript",
    "Next.js",
    "Pattern"
  ],
  "lang": "it",
  "body": {
    "raw": "\n# TypeScript ovunque: pattern UI più sicuri in Next.js\n\nTypeScript è diventato uno strumento essenziale per costruire applicazioni frontend robuste. In questo post, condividerò alcuni pattern avanzati che uso per rendere le applicazioni Next.js più type-safe e manutenibili.\n\n## Il Potere del TypeScript Strict\n\nPrima di tutto, parliamo della configurazione TypeScript. Inizio sempre con la modalità strict abilitata:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n```\n\n## Pattern 1: Route API Type-Safe\n\nUno dei miei pattern preferiti è creare route API type-safe:\n\n```typescript\n// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n```\n\n## Pattern 2: Props dei Componenti con Varianti\n\nUsare `class-variance-authority` con TypeScript crea API di componenti potenti e type-safe:\n\n```typescript\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n```\n\n## Pattern 3: Gestione Form con Zod\n\nCombinare TypeScript con Zod per la validazione dei form:\n\n```typescript\nimport { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Nome richiesto\"),\n  email: z.string().email(\"Email non valida\"),\n  age: z.number().min(18, \"Devi avere almeno 18 anni\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n```\n\n## Punti Chiave\n\n1. **Inizia con TypeScript strict** - Cattura più errori al momento della compilazione\n2. **Usa le union discriminate** - Rendono impossibili gli stati impossibili\n3. **Sfrutta i tipi di utilità** - `Pick`, `Omit`, e `Partial` sono tuoi amici\n4. **Tipizza le risposte API** - La type safety end-to-end vale lo sforzo\n\nTypeScript non serve solo a catturare bug—serve a creare migliori esperienze per gli sviluppatori e codebase più manutenibili.\n",
    "code": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),f=(i,e)=>{for(var t in e)a(i,t,{get:e[t],enumerable:!0})},c=(i,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!y.call(i,r)&&r!==t&&a(i,r,{get:()=>e[r],enumerable:!(o=h(e,r))||o.enumerable});return i};var x=(i,e,t)=>(t=i!=null?d(m(i)):{},c(e||!i||!i.__esModule?a(t,\"default\",{value:i,enumerable:!0}):t,i)),v=i=>c(a({},\"__esModule\",{value:!0}),i);var s=g((T,p)=>{p.exports=_jsx_runtime});var j={};f(j,{default:()=>P,frontmatter:()=>z});var n=x(s()),z={title:\"TypeScript ovunque: pattern UI pi\\xF9 sicuri in Next.js\",date:\"2024-01-10\",summary:\"Esplorando pattern TypeScript avanzati che rendono le tue applicazioni Next.js pi\\xF9 robuste e manutenibili.\",tags:[\"TypeScript\",\"Next.js\",\"Pattern\"],lang:\"it\"};function l(i){let e=Object.assign({h1:\"h1\",a:\"a\",p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"typescript-ovunque-pattern-ui-pi\\xF9-sicuri-in-nextjs\",children:(0,n.jsx)(e.a,{href:\"#typescript-ovunque-pattern-ui-pi\\xF9-sicuri-in-nextjs\",children:\"TypeScript ovunque: pattern UI pi\\xF9 sicuri in Next.js\"})}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript \\xE8 diventato uno strumento essenziale per costruire applicazioni frontend robuste. In questo post, condivider\\xF2 alcuni pattern avanzati che uso per rendere le applicazioni Next.js pi\\xF9 type-safe e manutenibili.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"il-potere-del-typescript-strict\",children:(0,n.jsx)(e.a,{href:\"#il-potere-del-typescript-strict\",children:\"Il Potere del TypeScript Strict\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Prima di tutto, parliamo della configurazione TypeScript. Inizio sempre con la modalit\\xE0 strict abilitata:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-json\",children:`{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-1-route-api-type-safe\",children:(0,n.jsx)(e.a,{href:\"#pattern-1-route-api-type-safe\",children:\"Pattern 1: Route API Type-Safe\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Uno dei miei pattern preferiti \\xE8 creare route API type-safe:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(\\`/api/users/\\${id}\\`);\n  return response.json();\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-2-props-dei-componenti-con-varianti\",children:(0,n.jsx)(e.a,{href:\"#pattern-2-props-dei-componenti-con-varianti\",children:\"Pattern 2: Props dei Componenti con Varianti\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Usare \",(0,n.jsx)(e.code,{children:\"class-variance-authority\"}),\" con TypeScript crea API di componenti potenti e type-safe:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-3-gestione-form-con-zod\",children:(0,n.jsx)(e.a,{href:\"#pattern-3-gestione-form-con-zod\",children:\"Pattern 3: Gestione Form con Zod\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Combinare TypeScript con Zod per la validazione dei form:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Nome richiesto\"),\n  email: z.string().email(\"Email non valida\"),\n  age: z.number().min(18, \"Devi avere almeno 18 anni\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"punti-chiave\",children:(0,n.jsx)(e.a,{href:\"#punti-chiave\",children:\"Punti Chiave\"})}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Inizia con TypeScript strict\"}),\" - Cattura pi\\xF9 errori al momento della compilazione\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Usa le union discriminate\"}),\" - Rendono impossibili gli stati impossibili\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Sfrutta i tipi di utilit\\xE0\"}),\" - \",(0,n.jsx)(e.code,{children:\"Pick\"}),\", \",(0,n.jsx)(e.code,{children:\"Omit\"}),\", e \",(0,n.jsx)(e.code,{children:\"Partial\"}),\" sono tuoi amici\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Tipizza le risposte API\"}),\" - La type safety end-to-end vale lo sforzo\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript non serve solo a catturare bug\\u2014serve a creare migliori esperienze per gli sviluppatori e codebase pi\\xF9 manutenibili.\"})]})}function b(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(l,i)})):l(i)}var P=b;return v(j);})();\n;return Component;"
  },
  "_id": "posts/typescript-everywhere-safer-ui-patterns-it.mdx",
  "_raw": {
    "sourceFilePath": "posts/typescript-everywhere-safer-ui-patterns-it.mdx",
    "sourceFileName": "typescript-everywhere-safer-ui-patterns-it.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/typescript-everywhere-safer-ui-patterns-it"
  },
  "type": "Post",
  "slug": "typescript-everywhere-safer-ui-patterns-it",
  "url": "/it/blog/typescript-everywhere-safer-ui-patterns-it"
}