{
  "title": "TypeScript en todas partes: patrones de UI más seguros en Next.js",
  "date": "2024-01-10T00:00:00.000Z",
  "summary": "Explorando patrones avanzados de TypeScript que hacen tus aplicaciones Next.js más robustas y mantenibles.",
  "tags": [
    "TypeScript",
    "Next.js",
    "Patrones"
  ],
  "lang": "es",
  "body": {
    "raw": "\n# TypeScript en todas partes: patrones de UI más seguros en Next.js\n\nTypeScript se ha convertido en una herramienta esencial para construir aplicaciones frontend robustas. En este post, compartiré algunos patrones avanzados que uso para hacer las aplicaciones Next.js más type-safe y mantenibles.\n\n## El Poder del TypeScript Estricto\n\nPrimero, hablemos sobre la configuración de TypeScript. Siempre empiezo con el modo estricto habilitado:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n```\n\n## Patrón 1: Rutas API Type-Safe\n\nUno de mis patrones favoritos es crear rutas API type-safe:\n\n```typescript\n// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n```\n\n## Patrón 2: Props de Componentes con Variantes\n\nUsar `class-variance-authority` con TypeScript crea APIs de componentes poderosas y type-safe:\n\n```typescript\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n```\n\n## Patrón 3: Manejo de Formularios con Zod\n\nCombinando TypeScript con Zod para validación de formularios:\n\n```typescript\nimport { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Nombre requerido\"),\n  email: z.string().email(\"Email inválido\"),\n  age: z.number().min(18, \"Debes tener al menos 18 años\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n```\n\n## Puntos Clave\n\n1. **Empieza con TypeScript estricto** - Captura más errores en tiempo de compilación\n2. **Usa uniones discriminadas** - Hacen imposibles los estados imposibles\n3. **Aprovecha los tipos de utilidad** - `Pick`, `Omit`, y `Partial` son tus amigos\n4. **Tipifica las respuestas de API** - La seguridad de tipos end-to-end vale el esfuerzo\n\nTypeScript no es solo para capturar bugs—es para crear mejores experiencias de desarrollador y bases de código más mantenibles.\n",
    "code": "var Component=(()=>{var l=Object.create;var t=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),f=(r,e)=>{for(var s in e)t(r,s,{get:e[s],enumerable:!0})},o=(r,e,s,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of h(e))!y.call(r,a)&&a!==s&&t(r,a,{get:()=>e[a],enumerable:!(i=m(e,a))||i.enumerable});return r};var x=(r,e,s)=>(s=r!=null?l(u(r)):{},o(e||!r||!r.__esModule?t(s,\"default\",{value:r,enumerable:!0}):s,r)),b=r=>o(t({},\"__esModule\",{value:!0}),r);var p=g((S,c)=>{c.exports=_jsx_runtime});var T={};f(T,{default:()=>P,frontmatter:()=>j});var n=x(p()),j={title:\"TypeScript en todas partes: patrones de UI m\\xE1s seguros en Next.js\",date:\"2024-01-10\",summary:\"Explorando patrones avanzados de TypeScript que hacen tus aplicaciones Next.js m\\xE1s robustas y mantenibles.\",tags:[\"TypeScript\",\"Next.js\",\"Patrones\"],lang:\"es\"};function d(r){let e=Object.assign({h1:\"h1\",a:\"a\",p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"typescript-en-todas-partes-patrones-de-ui-m\\xE1s-seguros-en-nextjs\",children:(0,n.jsx)(e.a,{href:\"#typescript-en-todas-partes-patrones-de-ui-m\\xE1s-seguros-en-nextjs\",children:\"TypeScript en todas partes: patrones de UI m\\xE1s seguros en Next.js\"})}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript se ha convertido en una herramienta esencial para construir aplicaciones frontend robustas. En este post, compartir\\xE9 algunos patrones avanzados que uso para hacer las aplicaciones Next.js m\\xE1s type-safe y mantenibles.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"el-poder-del-typescript-estricto\",children:(0,n.jsx)(e.a,{href:\"#el-poder-del-typescript-estricto\",children:\"El Poder del TypeScript Estricto\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Primero, hablemos sobre la configuraci\\xF3n de TypeScript. Siempre empiezo con el modo estricto habilitado:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-json\",children:`{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"patr\\xF3n-1-rutas-api-type-safe\",children:(0,n.jsx)(e.a,{href:\"#patr\\xF3n-1-rutas-api-type-safe\",children:\"Patr\\xF3n 1: Rutas API Type-Safe\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Uno de mis patrones favoritos es crear rutas API type-safe:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(\\`/api/users/\\${id}\\`);\n  return response.json();\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"patr\\xF3n-2-props-de-componentes-con-variantes\",children:(0,n.jsx)(e.a,{href:\"#patr\\xF3n-2-props-de-componentes-con-variantes\",children:\"Patr\\xF3n 2: Props de Componentes con Variantes\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Usar \",(0,n.jsx)(e.code,{children:\"class-variance-authority\"}),\" con TypeScript crea APIs de componentes poderosas y type-safe:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"patr\\xF3n-3-manejo-de-formularios-con-zod\",children:(0,n.jsx)(e.a,{href:\"#patr\\xF3n-3-manejo-de-formularios-con-zod\",children:\"Patr\\xF3n 3: Manejo de Formularios con Zod\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Combinando TypeScript con Zod para validaci\\xF3n de formularios:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Nombre requerido\"),\n  email: z.string().email(\"Email inv\\xE1lido\"),\n  age: z.number().min(18, \"Debes tener al menos 18 a\\xF1os\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"puntos-clave\",children:(0,n.jsx)(e.a,{href:\"#puntos-clave\",children:\"Puntos Clave\"})}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Empieza con TypeScript estricto\"}),\" - Captura m\\xE1s errores en tiempo de compilaci\\xF3n\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Usa uniones discriminadas\"}),\" - Hacen imposibles los estados imposibles\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Aprovecha los tipos de utilidad\"}),\" - \",(0,n.jsx)(e.code,{children:\"Pick\"}),\", \",(0,n.jsx)(e.code,{children:\"Omit\"}),\", y \",(0,n.jsx)(e.code,{children:\"Partial\"}),\" son tus amigos\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Tipifica las respuestas de API\"}),\" - La seguridad de tipos end-to-end vale el esfuerzo\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript no es solo para capturar bugs\\u2014es para crear mejores experiencias de desarrollador y bases de c\\xF3digo m\\xE1s mantenibles.\"})]})}function v(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(d,r)})):d(r)}var P=v;return b(T);})();\n;return Component;"
  },
  "_id": "posts/typescript-everywhere-safer-ui-patterns-es.mdx",
  "_raw": {
    "sourceFilePath": "posts/typescript-everywhere-safer-ui-patterns-es.mdx",
    "sourceFileName": "typescript-everywhere-safer-ui-patterns-es.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/typescript-everywhere-safer-ui-patterns-es"
  },
  "type": "Post",
  "slug": "typescript-everywhere-safer-ui-patterns-es",
  "url": "/es/blog/typescript-everywhere-safer-ui-patterns-es"
}