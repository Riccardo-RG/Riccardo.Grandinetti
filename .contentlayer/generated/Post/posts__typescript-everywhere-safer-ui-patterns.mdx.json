{
  "title": "TypeScript everywhere: safer UI patterns in Next.js",
  "date": "2024-01-10T00:00:00.000Z",
  "summary": "Exploring advanced TypeScript patterns that make your Next.js applications more robust and maintainable.",
  "tags": [
    "TypeScript",
    "Next.js",
    "Patterns"
  ],
  "lang": "en",
  "body": {
    "raw": "\n# TypeScript everywhere: safer UI patterns in Next.js\n\nTypeScript has become an essential tool for building robust frontend applications. In this post, I'll share some advanced patterns I use to make Next.js applications more type-safe and maintainable.\n\n## The Power of Strict TypeScript\n\nFirst, let's talk about TypeScript configuration. I always start with strict mode enabled:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n```\n\n## Pattern 1: Type-Safe API Routes\n\nOne of my favorite patterns is creating type-safe API routes:\n\n```typescript\n// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n}\n```\n\n## Pattern 2: Component Props with Variants\n\nUsing `class-variance-authority` with TypeScript creates powerful, type-safe component APIs:\n\n```typescript\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n```\n\n## Pattern 3: Form Handling with Zod\n\nCombining TypeScript with Zod for form validation:\n\n```typescript\nimport { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Name is required\"),\n  email: z.string().email(\"Invalid email\"),\n  age: z.number().min(18, \"Must be 18 or older\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n```\n\n## Key Takeaways\n\n1. **Start with strict TypeScript** - It catches more errors at compile time\n2. **Use discriminated unions** - They make impossible states impossible\n3. **Leverage utility types** - `Pick`, `Omit`, and `Partial` are your friends\n4. **Type your API responses** - End-to-end type safety is worth the effort\n\nTypeScript isn't just about catching bugsâ€”it's about creating better developer experiences and more maintainable codebases.\n",
    "code": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!u.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(s=h(e,i))||s.enumerable});return t};var x=(t,e,r)=>(r=t!=null?d(y(t)):{},o(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),b=t=>o(a({},\"__esModule\",{value:!0}),t);var p=f((S,c)=>{c.exports=_jsx_runtime});var j={};g(j,{default:()=>T,frontmatter:()=>w});var n=x(p()),w={title:\"TypeScript everywhere: safer UI patterns in Next.js\",date:\"2024-01-10\",summary:\"Exploring advanced TypeScript patterns that make your Next.js applications more robust and maintainable.\",tags:[\"TypeScript\",\"Next.js\",\"Patterns\"],lang:\"en\"};function l(t){let e=Object.assign({h1:\"h1\",a:\"a\",p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"typescript-everywhere-safer-ui-patterns-in-nextjs\",children:(0,n.jsx)(e.a,{href:\"#typescript-everywhere-safer-ui-patterns-in-nextjs\",children:\"TypeScript everywhere: safer UI patterns in Next.js\"})}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript has become an essential tool for building robust frontend applications. In this post, I'll share some advanced patterns I use to make Next.js applications more type-safe and maintainable.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"the-power-of-strict-typescript\",children:(0,n.jsx)(e.a,{href:\"#the-power-of-strict-typescript\",children:\"The Power of Strict TypeScript\"})}),`\n`,(0,n.jsx)(e.p,{children:\"First, let's talk about TypeScript configuration. I always start with strict mode enabled:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-json\",children:`{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-1-type-safe-api-routes\",children:(0,n.jsx)(e.a,{href:\"#pattern-1-type-safe-api-routes\",children:\"Pattern 1: Type-Safe API Routes\"})}),`\n`,(0,n.jsx)(e.p,{children:\"One of my favorite patterns is creating type-safe API routes:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`// types/api.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport interface ApiResponse<T> {\n  data: T;\n  error?: string;\n}\n\n// lib/api.ts\nexport async function fetchUser(id: string): Promise<ApiResponse<User>> {\n  const response = await fetch(\\`/api/users/\\${id}\\`);\n  return response.json();\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-2-component-props-with-variants\",children:(0,n.jsx)(e.a,{href:\"#pattern-2-component-props-with-variants\",children:\"Pattern 2: Component Props with Variants\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"class-variance-authority\"}),\" with TypeScript creates powerful, type-safe component APIs:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { cva, type VariantProps } from \"class-variance-authority\";\n\nconst buttonVariants = cva(\"button\", {\n  variants: {\n    variant: {\n      primary: \"bg-blue-500 text-white\",\n      secondary: \"bg-gray-200 text-gray-900\",\n    },\n    size: {\n      sm: \"px-2 py-1 text-sm\",\n      lg: \"px-4 py-2 text-lg\",\n    },\n  },\n});\n\ninterface ButtonProps extends VariantProps<typeof buttonVariants> {\n  children: React.ReactNode;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"pattern-3-form-handling-with-zod\",children:(0,n.jsx)(e.a,{href:\"#pattern-3-form-handling-with-zod\",children:\"Pattern 3: Form Handling with Zod\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Combining TypeScript with Zod for form validation:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`import { z } from \"zod\";\n\nconst userSchema = z.object({\n  name: z.string().min(1, \"Name is required\"),\n  email: z.string().email(\"Invalid email\"),\n  age: z.number().min(18, \"Must be 18 or older\"),\n});\n\ntype UserFormData = z.infer<typeof userSchema>;\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"key-takeaways\",children:(0,n.jsx)(e.a,{href:\"#key-takeaways\",children:\"Key Takeaways\"})}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Start with strict TypeScript\"}),\" - It catches more errors at compile time\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use discriminated unions\"}),\" - They make impossible states impossible\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Leverage utility types\"}),\" - \",(0,n.jsx)(e.code,{children:\"Pick\"}),\", \",(0,n.jsx)(e.code,{children:\"Omit\"}),\", and \",(0,n.jsx)(e.code,{children:\"Partial\"}),\" are your friends\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Type your API responses\"}),\" - End-to-end type safety is worth the effort\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"TypeScript isn't just about catching bugs\\u2014it's about creating better developer experiences and more maintainable codebases.\"})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var T=v;return b(j);})();\n;return Component;"
  },
  "_id": "posts/typescript-everywhere-safer-ui-patterns.mdx",
  "_raw": {
    "sourceFilePath": "posts/typescript-everywhere-safer-ui-patterns.mdx",
    "sourceFileName": "typescript-everywhere-safer-ui-patterns.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/typescript-everywhere-safer-ui-patterns"
  },
  "type": "Post",
  "slug": "typescript-everywhere-safer-ui-patterns",
  "url": "/en/blog/typescript-everywhere-safer-ui-patterns"
}